<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML Game with Dynamic Rooms</title>
    <style>
        body {
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f0f0f0;
            font-family: Arial, sans-serif;
        }
        #gameContainer {
            position: relative;
            display: inline-block;
        }
        #gameCanvas {
            border: 1px solid #000;
        }
        #controls {
            margin-top: 10px;
            text-align: center;
        }
        #status {
            margin-top: 10px;
            font-size: 16px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
    </div>
    <div id="controls">
        <button onclick="move('north')">North</button>
        <button onclick="move('south')">South</button>
        <button onclick="move('east')">East</button>
        <button onclick="move('west')">West</button>
    </div>
    <div id="status">Current Room: (0,0)</div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Grid and octagon settings (matched to your room designer)
        const gridRows = 5;
        const gridCols = 7;
        const sideLength = 30;
        const diagonalProjection = sideLength * Math.SQRT2 / 2;
        const octagonSpan = sideLength + 2 * diagonalProjection;
        const padding = diagonalProjection;
        const sidewallThickness = 10;
        const doorSize = 30;
        const canvasWidth = gridCols * octagonSpan + 2 * padding;
        const canvasHeight = gridRows * octagonSpan + 2 * padding;

        // Handle device pixel ratio
        const dpr = window.devicePixelRatio || 1;
        canvas.width = canvasWidth * dpr;
        canvas.height = canvasHeight * dpr;
        canvas.style.width = `${canvasWidth}px`;
        canvas.style.height = `${canvasHeight}px`;
        ctx.scale(dpr, dpr);

        // Door areas (matched to your room designer)
        const doorAreas = {
            north: { x: (canvasWidth - doorSize) / 2, y: 0, width: doorSize, height: doorSize },
            south: { x: (canvasWidth - doorSize) / 2, y: canvasHeight - doorSize, width: doorSize, height: doorSize },
            east: { x: canvasWidth - doorSize, y: (canvasHeight - doorSize) / 2, width: doorSize, height: doorSize },
            west: { x: 0, y: (canvasHeight - doorSize) / 2, width: doorSize, height: doorSize }
        };

        // Room cache and current state
        const roomCache = new Map();
        let currentRoom = null;
        let currentX = 0;
        let currentY = 0;

        // Load a room from JSON
        async function loadRoom(x, y) {
            try {
                const response = await fetch(`rooms/room_${x}_${y}.json`);
                if (!response.ok) throw new Error('Room not found');
                const roomData = await response.json();
                return roomData;
            } catch (error) {
                console.error(`Failed to load room ${x},${y}:`, error);
                return null;
            }
        }

        // Get or load a room, caching it
        async function getRoom(x, y) {
            const key = `${x},${y}`;
            if (!roomCache.has(key)) {
                const roomData = await loadRoom(x, y);
                if (roomData) roomCache.set(key, roomData);
            }
            return roomCache.get(key);
        }

        // Preload adjacent rooms
        async function preloadAdjacentRooms(x, y) {
            const directions = [
                [0, 1],  // North
                [0, -1], // South
                [1, 0],  // East
                [-1, 0]  // West
            ];
            for (const [dx, dy] of directions) {
                await getRoom(x + dx, y + dy);
            }
        }

        // Initialize the game
        async function init() {
            currentRoom = await getRoom(currentX, currentY);
            if (currentRoom) {
                await preloadAdjacentRooms(currentX, currentY);
                drawRoom(currentRoom);
                updateStatus();
            } else {
                document.getElementById('status').textContent = `Error: Room (${currentX},${currentY}) not found`;
            }
        }

        // Move to a new room
        async function move(direction) {
            const doorState = currentRoom?.doors[direction];
            if (doorState === 'Locked' || doorState === 'No Door') {
                document.getElementById('status').textContent = `Cannot move ${direction}: Door is ${doorState}`;
                return;
            }

            const directionMap = {
                north: [0, 1],
                south: [0, -1],
                east: [1, 0],
                west: [-1, 0]
            };
            const [dx, dy] = directionMap[direction];
            const newX = currentX + dx;
            const newY = currentY + dy;

            const newRoom = await getRoom(newX, newY);
            if (newRoom) {
                currentRoom = newRoom;
                currentX = newX;
                currentY = newY;
                await preloadAdjacentRooms(newX, newY);
                drawRoom(currentRoom);
                updateStatus();
            } else {
                document.getElementById('status').textContent = `Cannot move ${direction}: Room (${newX},${newY}) not found`;
            }
        }

        // Update status display
        function updateStatus() {
            document.getElementById('status').textContent = `Current Room: (${currentX},${currentY})`;
        }

        // Draw a room from JSON data
        function drawRoom(roomData) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw background
            ctx.fillStyle = roomData.backgroundColor || '#f0f0f0';
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);

            // Draw sidewalls
            ctx.fillStyle = roomData.sidewalls.top || 'gray';
            ctx.fillRect(0, 0, canvasWidth, sidewallThickness);
            ctx.fillStyle = roomData.sidewalls.right || 'gray';
            ctx.fillRect(canvasWidth - sidewallThickness, 0, sidewallThickness, canvasHeight);
            ctx.fillStyle = roomData.sidewalls.bottom || 'gray';
            ctx.fillRect(0, canvasHeight - sidewallThickness, canvasWidth, sidewallThickness);
            ctx.fillStyle = roomData.sidewalls.left || 'gray';
            ctx.fillRect(0, 0, sidewallThickness, canvasHeight);

            // Draw doors
            for (const [direction, area] of Object.entries(doorAreas)) {
                const state = roomData.doors[direction] || 'Unlocked';
                ctx.fillStyle = getDoorColor(state);
                ctx.fillRect(area.x, area.y, area.width, area.height);
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                ctx.strokeRect(area.x, area.y, area.width, area.height);
                ctx.fillStyle = '#000';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(state, area.x + area.width / 2, area.y + area.height / 2);
            }

            // Draw octagons
            const octagonMap = new Map(roomData.octagons.map(o => [o.id, o]));
            for (let row = 0; row < gridRows; row++) {
                for (let col = 0; col < gridCols; col++) {
                    const id = `${row},${col}`;
                    const data = octagonMap.get(id) || { color: 'teal', gameObject: null };
                    const baseX = col * octagonSpan + padding;
                    const baseY = row * octagonSpan + padding;
                    const points = [
                        { x: baseX, y: baseY + diagonalProjection },
                        { x: baseX + diagonalProjection, y: baseY },
                        { x: baseX + diagonalProjection + sideLength, y: baseY },
                        { x: baseX + octagonSpan, y: baseY + diagonalProjection },
                        { x: baseX + octagonSpan, y: baseY + diagonalProjection + sideLength },
                        { x: baseX + diagonalProjection + sideLength, y: baseY + octagonSpan },
                        { x: baseX + diagonalProjection, y: baseY + octagonSpan },
                        { x: baseX, y: baseY + diagonalProjection + sideLength }
                    ];

                    ctx.beginPath();
                    points.forEach((p, i) => i === 0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y));
                    ctx.closePath();
                    ctx.fillStyle = data.color;
                    ctx.fill();
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    if (data.gameObject) {
                        const centerX = (points[1].x + points[5].x) / 2;
                        const centerY = (points[1].y + points[5].y) / 2;
                        ctx.font = '20px Arial';
                        ctx.fillStyle = '#000';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(data.gameObject, centerX, centerY);
                    }
                }
            }

            // Draw squares
            const squareMap = new Map(roomData.squares.map(s => [s.id, s]));
            for (let row = 0; row < gridRows - 1; row++) {
                for (let col = 0; col < gridCols - 1; col++) {
                    const id = `${row},${col}`;
                    const color = squareMap.get(id)?.color || 'magenta';
                    const points = [
                        { x: col * octagonSpan + padding + octagonSpan, y: row * octagonSpan + padding + diagonalProjection + sideLength },
                        { x: (col + 1) * octagonSpan + padding + diagonalProjection, y: row * octagonSpan + padding + octagonSpan },
                        { x: (col + 1) * octagonSpan + padding, y: (row + 1) * octagonSpan + padding + diagonalProjection },
                        { x: col * octagonSpan + padding + diagonalProjection + sideLength, y: (row + 1) * octagonSpan + padding }
                    ];

                    ctx.beginPath();
                    points.forEach((p, i) => i === 0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y));
                    ctx.closePath();
                    ctx.fillStyle = color;
                    ctx.fill();
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }
        }

        // Get door color based on state
        function getDoorColor(state) {
            return {
                'Unlocked': 'green',
                'Locked': 'red',
                'No Door': 'gray',
                'Secret': 'yellow'
            }[state] || 'gray';
        }

        // Start the game
        init();
    </script>
</body>
</html>